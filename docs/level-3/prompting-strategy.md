---
sidebar_position: 10
title: 프롬프트 전략
description: Claude Code에서 더 나은 결과를 얻기 위한 고급 프롬프팅 기법과 패턴을 배웁니다.
---

# 프롬프트 전략

Claude Code를 잘 쓰는 사람과 그렇지 않은 사람의 차이는 **프롬프트 품질**에서 나옵니다. 같은 작업이라도 어떻게 요청하느냐에 따라 결과가 크게 달라집니다. 이 챕터에서는 검증된 고급 프롬프팅 기법을 다룹니다.

## 기본 원칙: 명확성 > 간결성

초보자는 짧게 요청하는 것이 좋다고 생각합니다. 하지만 실제로는 **구체적이고 명확한 요청**이 더 좋은 결과를 냅니다.

```
# 나쁜 예
> 로그인 만들어줘

# 좋은 예
> JWT 기반 로그인 API를 만들어줘.
  - POST /auth/login 엔드포인트
  - 요청: { email, password }
  - 성공 응답: { accessToken, refreshToken, user }
  - 실패: 401 에러 (잘못된 비밀번호), 404 에러 (없는 계정)
  - bcrypt로 비밀번호 검증
  - 기존 src/users/user.model.ts 의 User 모델 활용
```

## 기법 1: 역할 부여 (Role Prompting)

Claude에게 특정 역할을 부여하면 그 분야의 관점에서 응답합니다:

```
> 시니어 Node.js 개발자 관점에서 이 코드를 리뷰해줘.
  특히 확장성과 유지보수성 측면에서.

> 보안 전문가 입장에서 이 인증 코드의 취약점을 찾아줘.

> 이 시스템의 사용자가 된 것처럼, UX 관점에서
  API 응답 구조가 적절한지 평가해줘.
```

## 기법 2: 제약 조건 명시

제약 조건이 많을수록 원하는 결과에 가까워집니다:

```
> OAuth2 소셜 로그인을 구현해줘. 단:
  - passport.js 사용하지 마 (직접 구현)
  - TypeScript strict 모드 준수
  - 외부 HTTP 라이브러리 없이 Node.js fetch 사용
  - 기존 AuthService 클래스를 확장하는 방식으로
  - 테스트 코드 포함
```

## 기법 3: 예시 기반 요청 (Few-shot)

원하는 패턴의 예시를 보여주면 Claude가 동일한 패턴을 따릅니다:

```
> 이 패턴을 따라서 Product 서비스를 만들어줘:

  // User 서비스 예시 (이 패턴을 따라줘):
  export class UserService {
    constructor(private readonly db: Database) {}

    async findById(id: number): Promise<User | null> {
      return this.db.users.findUnique({ where: { id } });
    }

    async create(data: CreateUserDto): Promise<User> {
      return this.db.users.create({ data });
    }
  }

  // 이와 동일한 구조로 ProductService 만들어줘.
  // 메서드: findById, findAll, create, update, delete
```

## 기법 4: 단계별 사고 유도 (Chain of Thought)

복잡한 문제에서 Claude가 단계별로 생각하게 유도합니다:

```
> 이 성능 문제를 해결해줘.
  수정하기 전에:
  1. 병목이 어디인지 분석
  2. 가능한 해결 방법 3가지 나열
  3. 각 방법의 장단점 비교
  4. 최선의 방법 선택 후 구현
```

```
> 이 코드의 보안 취약점을 단계적으로 분석해줘:
  1. 입력 검증 문제
  2. 인증/인가 문제
  3. 데이터 노출 문제
  4. 각 문제별 수정 방법
```

## 기법 5: 부정적 지시사항

"하지 말 것"을 명확히 하면 원하지 않는 결과를 피할 수 있습니다:

```
> 사용자 삭제 기능을 구현해줘.
  - soft delete 사용 (실제로 DB에서 삭제하지 마)
  - 관련 데이터는 건드리지 마
  - 기존 deleteUser 함수 수정하지 말고 새 함수 추가해
  - 에러 처리 코드는 건드리지 마
```

## 기법 6: 출력 형식 지정

원하는 출력 형식을 명확히 지정합니다:

```
> 이 코드베이스 분석 결과를 다음 형식으로 알려줘:
  ## 강점
  [목록]

  ## 개선 필요 부분
  [우선순위별 목록]

  ## 즉시 수정 필요
  [크리티컬한 문제들]

> 코드 리뷰 결과를 GitHub PR 코멘트 형식으로 작성해줘.
  파일명과 라인 번호를 포함해서.
```

## 기법 7: 검증 요청 포함

구현과 함께 검증을 요청합니다:

```
> 할인 계산 함수를 구현해줘.
  구현 후에:
  1. 엣지 케이스 목록 작성
  2. 각 엣지 케이스에 대한 테스트 실행
  3. 모든 테스트 통과 확인 후 완료

> 이 API를 구현해줘.
  완료 후 다음을 직접 확인해줘:
  - TypeScript 컴파일 오류 없음
  - 린트 오류 없음
  - 관련 테스트 통과
```

## 기법 8: 이터레이티브 개선

한 번에 완벽한 결과를 기대하지 말고 단계적으로 개선합니다:

```
# 1단계: 기능 먼저
> 일단 동작하는 버전으로 빠르게 구현해줘.
  코드 품질은 나중에 개선할게.

# 2단계: 리뷰
> 방금 구현한 코드에서 개선할 점 3가지 알려줘.

# 3단계: 개선
> 그 중 [가장 중요한 것] 먼저 개선해줘.

# 4단계: 테스트
> 이제 테스트 추가해줘.
```

## 맥락 설정 패턴

### 작업 시작 시 컨텍스트 제공

```
> 지금부터 [기능명] 기능을 구현할 거야.
  배경:
  - 현재 [현재 상태]
  - 목표: [최종 목표]
  - 제약: [제약 조건]

  첫 번째로 [첫 작업]부터 시작해줘.
```

### 중간 지점에서 방향 재확인

```
> 지금까지 구현한 내용을 요약해줘.
  다음 단계가 뭔지 확인하고 싶어.
```

### 작업 완료 시 검토 요청

```
> 오늘 작업한 코드 전체를 돌아봐줘.
  일관성 없는 부분이나 개선할 점 있으면 알려줘.
```

## 도메인별 효과적인 프롬프트 패턴

### 버그 수정

```
> 버그: [증상 설명]
  발생 조건: [언제 발생하는지]
  에러 메시지: [에러 내용]
  예상 동작: [올바른 동작]
  실제 동작: [실제로 일어나는 일]

  원인 파악 후 수정해줘.
  수정 이유도 설명해줘.
```

### 성능 최적화

```
> 이 코드의 성능을 개선해줘.
  현재 문제: [어떤 성능 문제인지]
  목표: [목표 성능 수치 또는 개선 방향]
  제약: [바꾸면 안 되는 것들]

  개선 방법과 예상 효과를 설명하면서 진행해줘.
```

### 코드 리뷰

```
> 시니어 개발자처럼 이 코드를 리뷰해줘.
  다음 관점에서:
  1. 정확성 (버그 가능성)
  2. 가독성 (유지보수 용이성)
  3. 성능 (최적화 여지)
  4. 보안 (취약점)

  각 문제는 [심각도: 높음/중간/낮음]으로 분류해줘.
```

### 문서화

```
> 이 모듈에 대한 기술 문서를 작성해줘.
  대상 독자: 이 시스템에 처음 합류한 주니어 개발자
  포함 내용:
  - 모듈의 목적
  - 주요 클래스/함수와 역할
  - 일반적인 사용 예시 (코드 포함)
  - 주의사항
```

## 프롬프트 품질 셀프 체크리스트

요청 전에 확인:

- [ ] **무엇을**: 결과물이 명확한가?
- [ ] **어떻게**: 접근 방식에 제약이 있는가?
- [ ] **어디에**: 영향 범위가 지정되어 있는가?
- [ ] **왜**: 목적이 제공되어 있는가? (선택)
- [ ] **예시**: 참조할 패턴이나 예시가 있는가?
- [ ] **검증**: 완료 기준이 명확한가?

## 레벨 3 완료!

이 레벨을 마치면 Claude Code를 **중급 수준**으로 활용할 수 있습니다. Hooks 자동화, MCP 확장, 비용 최적화, CI/CD 통합, 대규모 코드베이스 관리, 고급 프롬프팅까지 — 실무에서 바로 쓸 수 있는 기술들을 갖췄습니다.

---

레벨 3를 완료했습니다! 다음 레벨로 도전해보세요.

[레벨 4 — 고급으로 →](/docs/level-4/intro)
